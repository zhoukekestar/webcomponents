<!-- https://github.com/Polymer/TemplateBinding -->
<!-- https://github.com/Polymer/TemplateBinding/blob/master/src/TemplateBinding.js -->
<style>
  template-mini:unresolved {
    display: none;
  }
</style>
<script>
  (function(){
    var proto = Object.create(HTMLElement.prototype)
      , directives = []

    var getExpressionValue = function (scope, expression) {
      return (new Function('with (this) {  return ' + expression + '}')).call(scope);
    }

    // Modal
    proto.modal = '';

    // Directives: repeat
    directives.push({
      name: 'z-repeat',
      parseChildren: false,
      handler: function(dom, expression, scope) {
        try {

          // Get parentNode, return if parent is null
          var parent = dom.parentNode;
          if (!parent) return;

          // Remove current template node.
          dom._remove = true;

          // transform expression into object
          var expression = expression.split(' in ');
          expression = {
            itemName: expression[0].trim(),
            items: getExpressionValue(scope, expression[1].trim())
          }

          // repeat
          for (var index in expression.items) {

            // Clone template node
            var cloneNode = dom.cloneNode(true);
            cloneNode.removeAttribute('z-repeat');

            // Set new scope
            scope[expression.itemName] = expression.items[index];
            scope.index = +index;

            // Append new parsed dom
            parent.appendChild(parseDom(cloneNode, scope))
          }

          delete scope.index;
          delete scope[expression.itemName];

        } catch (e) {
          console.warn('z-repeat ERROR:' + e);
          console.warn(dom);
        }

      }
    })

    // Directives: if
    directives.push({
      name: 'z-if',
      handler: function(dom, expression, scope) {
        var value = null;

        try {
          value = getExpressionValue(scope, expression);
        } catch (e) {
          console.warn('z-if ERROR:' + e + ' on dom:');
          console.warn(dom);
        }

        if (value) {
          dom.removeAttribute('z-if');
          dom._if = true;
          dom._ifarr = [true];
          return true;
        }
        dom._remove = true;
        dom._if = false;
        dom._ifarr = [false];
        return false;
      }
    })

    // Directives: elseif
    directives.push({
      name: 'z-elseif',
      handler: function(dom, expression, scope) {
        var value = null;
        var prev = dom.previousElementSibling;

        // if prev._ifarr has true, just return with false
        if (prev && prev._ifarr) {
          for (var i = 0; i < prev._ifarr.length; i++) {
            if (prev._ifarr[i]) {
              dom._remove = true;
              dom._if = false;
              dom._ifarr = prev._ifarr;
              dom._ifarr.push(false);
              return;
            }
          }
        }

        try {
          value = getExpressionValue(scope, expression);
        } catch (e) {
          console.warn('z-elseif ERROR:' + e + ' on dom:');
          console.warn(dom)
        }

        if (value) {
          dom.removeAttribute('z-elseif');
          prev && prev._ifarr && (dom._ifarr = prev._ifarr) && dom._ifarr.push(true) ;
          dom._if = true;
          return true;
        }
        dom._remove = true;
        dom._if = false;
        prev && prev._ifarr && (dom._ifarr = prev._ifarr) && dom._ifarr.push(false);
        return false;
      }
    });

    // Directives: else
    directives.push({
      name: 'z-else',
      handler: function(dom, expression, scope) {
        var prev = dom.previousElementSibling;
        if (prev && prev._ifarr) {
          for (var i = 0; i < prev._ifarr.length; i++) {
            if (prev._ifarr[i]) {
              dom._remove = true;
              dom._if = false;

              dom._ifarr = prev._ifarr;
              dom._ifarr.push(false);
              return;
            }
          }
        }

        dom._if = true;
        prev && prev._ifarr && (dom._ifarr = prev._ifarr) && dom._ifarr.push(true);
        dom.removeAttribute('z-else')
        return true;
      }
    });


    /**
     * Parse dom
     *  dom: the dom you want to parse
     *  scope: the data that will be used if some value shold be parsed
     **/
    var parseDom = function(dom, scope) {

      // Any `if` `elseif` directives return true, set this value to true.
      var isLastIfDirectiveEqualTrue = false;
      // var isIfDirective = false
      //   , isElseDirective = false;

      for (var i = 0; i < dom.children.length; i++) {
        var currentElement = dom.children[i];

        // Parse Children flag
        var parseChildren = true;
        // var isIfDirective = false
        //   , isElseDirective = false
        //   , elementRemoved = false;

        // Execute directives
        for (var j = 0; j < directives.length; j++) {

          var currentDirective = directives[j].name;
          var expression = currentElement.getAttribute(currentDirective);

          // Get current expression
          if (expression !== null) {

            // if (currentDirective === 'z-if') {
            //   isIfDirective = true;
            //   isLastIfDirectiveEqualTrue = false;
            // } else if (currentDirective === 'z-elseif' || currentDirective === 'z-else') {
            //   isElseDirective = true;
            // } else {
            //   isLastIfDirectiveEqualTrue = false;
            // }

            // Any `if' `elseif` return true, remove current dom.
            // if (isLastIfDirectiveEqualTrue && isElseDirective ) {
            //   currentElement.remove();
            //   elementRemoved = true;
            //
            // } else {

              parseChildren = parseChildren && directives[j].parseChildren === false ? false : true;

              // var returnValue =
              directives[j].handler(currentElement, expression, scope);
              // if ((isIfDirective || isElseDirective) && returnValue) {
              //   isLastIfDirectiveEqualTrue = returnValue;
              // }
              // elementRemoved = currentElement.parentNode === null ? true : false;
            // }

            break;
          }
        }

        // Element has children. And parseChildren is true (default is true)
        if (currentElement.children && currentElement.children.length > 0 && parseChildren && currentElement._remove !== true) {
          parseDom(currentElement, scope);
        }

        // if (!elementRemoved) {
        //   i++;
        // }
      }

      // Remove the node that _remove is true
      for (var i = dom.children.length - 1; i >= 0; i--) {
        if (dom.children[i]._remove === true) {
          dom.children[i].remove();
        }
      }


      dom.innerHTML = dom.innerHTML.replace(/{{(\S*?)}}/g, function() {
        try {
          return getExpressionValue(scope, arguments[1]);
        } catch (e) {
          console.warn(e);
          return '';
        }
      })

      return dom;
    }

    /*
     * Save innerHTML to _innerHTML
     */
    proto.createdCallback  = function() {
      this._innerHTML = this.innerHTML;
      this.style.display = 'none';
      try {
        if (this.dataset.modal) {
          this.setModal(JSON.parse(this.dataset.modal))
        }
      } catch (e) {
        console.warn(this)
        console.warn('Abolve element has invalid modal')
      }
    }

    /**
     * Set modal and apply it to dom.
     **/
    proto.setModal = function(d) {
      this.modal = d;
      this.style.display  = 'none';
      this.innerHTML = this._innerHTML;
      parseDom(this, this.modal);
      this.style.display = '';
      this.dispatchEvent(new Event('template-mini-updated', {bubbles: true}));
    }

    document.registerElement('template-mini', {
      prototype: proto
    });
  })();
</script>
