<!-- https://github.com/Polymer/TemplateBinding -->
<!-- https://github.com/Polymer/TemplateBinding/blob/master/src/TemplateBinding.js -->
<style>
  template-mini:unresolved {
    display: none;
  }
</style>
<script>
  (function(){
    var proto = Object.create(HTMLElement.prototype)
      , directives = []

    var getExpressionValue = function (scope, expression) {
      return (new Function('with (this) {  return ' + expression + '}')).call(scope);
    }

    // Modal
    proto.modal = '';

    // Directives: repeat
    directives.push({
      name: 'z-repeat',
      parseChildren: false,
      handler: function(dom, expression, scope) {
        try {
          var parent = dom.parentNode;
          dom.remove();

          // expression
          var expression = expression.split(' in ');
          expression = {
            itemName: expression[0].trim(),
            items: getExpressionValue(scope, expression[1].trim())
          }

          // repeat
          for (var index in expression.items) {
            var copyDom = dom.cloneNode(true);
            copyDom.removeAttribute('z-repeat');

            scope[expression.itemName] = expression.items[index];
            scope.index = +index;
            parent.appendChild(parseDom(copyDom, scope))
          }
          delete scope.index;
          delete scope[expression.itemName];

        } catch (e) {
          console.warn('z-repeat ERROR:' + e);
          console.warn(dom);
        }

      }
    })

    // Directives: if
    directives.push({
      name: 'z-if',
      handler: function(dom, expression, scope) {
        var value = null;

        try {
          value = getExpressionValue(scope, expression);
        } catch (e) {
          console.warn('z-if ERROR:' + e + ' on dom:');
          console.warn(dom);
        }

        if (value) {
          dom.removeAttribute('z-if');
          return true;
        }
        dom.remove();
        return false;
      }
    })

    // Directives: elseif
    directives.push({
      name: 'z-elseif',
      handler: function(dom, expression, scope) {
        var value = null;

        try {
          value = getExpressionValue(scope, expression);
        } catch (e) {
          console.warn('z-elseif ERROR:' + e + ' on dom:');
          console.warn(dom)
        }

        if (value) {
          dom.removeAttribute('z-elseif');
          return true;
        }
        dom.remove();
        return false;
      }
    });

    // Directives: else
    directives.push({
      name: 'z-else',
      handler: function(dom, expression, scope) {
        dom.removeAttribute('z-else')
        return true;
      }
    });


    /**
     * Parse dom
     *  dom: the dom you want to parse
     *  scope: the data that will be used if some value shold be parsed
     **/
    var parseDom = function(dom, scope) {

      // Any `if` `elseif` directives return true, set this value to true.
      var isLastIfDirectiveEqualTrue = false;
      var isIfDirective = false
        , isElseDirective = false;

      for (var i = 0; i < dom.children.length; ) {
        var currentElement = dom.children[i];

        // Parse Children flag
        var parseChildren = true;
        var isIfDirective = false
          , isElseDirective = false
          , elementRemoved = false;

        // Execute directives
        for (var j = 0; j < directives.length; j++) {

          var currentDirective = directives[j].name;
          var expression = currentElement.getAttribute(currentDirective);

          // Get current expression
          if (expression !== null) {

            if (currentDirective === 'z-if') {
              isIfDirective = true;
              isLastIfDirectiveEqualTrue = false;
            } else if (currentDirective === 'z-elseif' || currentDirective === 'z-else') {
              isElseDirective = true;
            } else {
              isLastIfDirectiveEqualTrue = false;
            }

            // Any `if' `elseif` return true, remove current dom.
            if (isLastIfDirectiveEqualTrue && isElseDirective ) {
              currentElement.remove();
              elementRemoved = true;

            } else {

              parseChildren = directives[j].parseChildren === false ? false : true;

              var returnValue = directives[j].handler(currentElement, expression, scope);
              if ((isIfDirective || isElseDirective) && returnValue) {
                isLastIfDirectiveEqualTrue = returnValue;
              }
              elementRemoved = currentElement.parentNode === null ? true : false;
            }

            break;
          }
        }

        // Element has children. And parse children is true
        if (currentElement.children && currentElement.children.length > 0 && parseChildren) {
          parseDom(currentElement, scope);
        }

        if (!elementRemoved) {
          i++;
        }
      }

      dom.innerHTML = dom.innerHTML.replace(/{{(\S*?)}}/g, function() {
        try {
          return getExpressionValue(scope, arguments[1]);
        } catch (e) {
          console.warn(e);
          return '';
        }
      })

      return dom;
    }

    /*
     * Save innerHTML to _innerHTML
     */
    proto.createdCallback  = function() {
      this._innerHTML = this.innerHTML;
      this.style.display = 'none';
      try {
        if (this.dataset.modal) {
          this.setModal(JSON.parse(this.dataset.modal))
        }
      } catch (e) {
        console.warn(this)
        console.warn('Abolve element has invalid modal')
      }
    }

    /**
     * Set modal and apply it to dom.
     **/
    proto.setModal = function(d) {
      this.modal = d;
      this.style.display  = 'none';
      this.innerHTML = this._innerHTML;
      parseDom(this, this.modal);
      this.style.display = '';
      this.dispatchEvent(new Event('template-mini-updated', {bubbles: true}));
    }

    document.registerElement('template-mini', {
      prototype: proto
    });
  })();
</script>
